import { ShoppingModel } from "./ShoppingModel.js";
import { OverviewView } from "./OverviewView.js";
import { DetailView } from "./DetailView.js";

export class ShoppingController {
    constructor() {
        this.model = new ShoppingModel();
        this.overviewView = new OverviewView();
        this.detailView = new DetailView();
        this.currentListId = null;
    }

    init() {
        this.model.loadLists();
        this.model.loadItems().then(() => {
            this.populateTagFilter(); // üîÑ Tag-Filter nach Laden aktualisieren
        });
        this.updateOverview();
        this.updateArticleView();


        document.getElementById("tag-filter").addEventListener("change", () => {
            this.updateArticleView();
        });


        document.getElementById("add-article").addEventListener("click", () => {
            const name = document.getElementById("new-article-name").value.trim();
            const tags = document.getElementById("new-article-tags").value.split(",").map(t => t.trim());
            const icon = document.getElementById("new-article-icon").value;

            if (name) {
                this.model.addArticle(name, tags, icon);
                this.updateArticleView();
            }
        });

        // Event-Listener f√ºr das Modal
        const modalElement = document.getElementById("add-item-modal");
        const openModalBtn = document.getElementById("open-add-item-modal");

        if (!modalElement) {
            console.error("Fehler: Modal-Element nicht gefunden!");
        } else if (!openModalBtn) {
            console.error("Fehler: Button zum √ñffnen des Modals nicht gefunden!");
        } else {
            this.addItemModal = new bootstrap.Modal(modalElement);
            openModalBtn.addEventListener("click", () => this.addItemModal.show());
        }
    }


    updateArticleView() {
        const tagFilter = document.getElementById("tag-filter").value;
        const articles = tagFilter && tagFilter !== ""
            ? this.model.getArticlesByTag(tagFilter)
            : this.model.articles; // ‚Üê Hier war das Problem!

        const list = document.getElementById("available-articles");
        if (!list) {
            console.error("‚ùå Fehler: `available-articles` wurde nicht gefunden!");
            return;
        }

        list.innerHTML = ""; // Vorherige Artikel l√∂schen

        articles.forEach(article => {
            const li = document.createElement("li");
            li.textContent = `${article.icon} ${article.name}`;
            li.onclick = () => {
                if (this.currentListId) {
                    this.model.addItemToList(this.currentListId, article.name, 1, article.icon);
                    this.showDetailView(this.currentListId);
                } else {
                    alert("‚ö†Ô∏è W√§hle zuerst eine Liste aus!");
                }
            };
            list.appendChild(li);
        });

        console.log("üîÑ Artikel-√úbersicht aktualisiert:", articles);
    }



    updateOverview() {
        const listContainer = document.getElementById("list-container");
        listContainer.innerHTML = ""; // Liste leeren

        const lists = this.model.getLists();
        this.overviewView.renderLists(lists, (listId) => {
            this.currentListId = listId;
            this.showDetailView(listId);
        });

        // üéØ Sicherstellen, dass der "Neue Liste"-Button nur einmal existiert
        if (!document.getElementById("add-list-button")) {
            this.addNewListButton();
        }
    }

// ‚úÖ Funktion zur √úberpr√ºfung, ob alle Artikel einer Liste erledigt sind
    isListCompleted(listId) {
        const list = this.model.getListById(listId);
        if (!list || list.items.length === 0) return false; // Falls die Liste leer ist, ist sie nicht "fertig"

        return list.items.every(item => item.archived); // Pr√ºft, ob ALLE Artikel `archived: true` sind
    }



    addNewListButton() {
        const listContainer = document.getElementById("list-container");
        if (!listContainer) return;

        // üî• Entferne alte Buttons bevor ein neuer hinzugef√ºgt wird
        const existingButtons = document.querySelectorAll("#add-list-button");
        existingButtons.forEach(button => button.remove());

        // Neuen Button erstellen
        const button = document.createElement("button");
        button.id = "add-list-button";
        button.classList.add("btn", "btn-primary", "mt-3");
        button.textContent = "Neue Liste";

        button.addEventListener("click", () => {
            const listName = prompt("Gib den Namen der neuen Liste ein:");
            if (listName) {
                this.model.addList(listName);
                this.updateOverview();
            }
        });

        listContainer.appendChild(button);
    }


    showDetailView(listId) {
        const list = this.model.getListById(listId);
        if (list) {
            document.getElementById("list-name").textContent = list.name;

            this.detailView.renderDetail(
                list,
                (name, quantity, icon) => {
                    this.model.addItemToList(listId, name, quantity, icon);
                    this.showDetailView(listId);
                },
                (listId, itemId) => {
                    this.model.toggleItemStatus(listId, itemId);
                    this.showDetailView(listId);
                    this.updateOverview();  // Listen√ºbersicht aktualisieren
                },
                (listId, itemId) => {
                    this.editItem(listId, itemId);
                },
                (listId, itemId) => {
                    this.deleteItem(listId, itemId);
                    this.updateOverview();  // Listen√ºbersicht aktualisieren
                },
                () => this.updateOverview()  // Hier `updateOverview` als Funktion √ºbergeben
            );


            document.getElementById("detail-view").style.display = "block";
        }
    }


    editItem(listId, itemId) {
        const item = this.model.getListById(listId).items.find(item => item.id === itemId);
        if (!item) return;

        const newName = prompt("Neuer Name f√ºr den Artikel:", item.name);
        const newQuantity = prompt("Neue Menge:", item.quantity);

        if (newName && newQuantity) {
            this.model.editItem(listId, itemId, newName, newQuantity);
            this.showDetailView(listId);
        }
    }

    deleteItem(listId, itemId) {
        if (confirm("M√∂chtest du diesen Artikel wirklich l√∂schen?")) {
            this.model.deleteItem(listId, itemId);
            this.showDetailView(listId);
        }
    }

    showListMenu(event, listId) {
        console.log(`üìå Men√º wird ge√∂ffnet f√ºr Listen-ID: ${listId}`);

        // Vorherige Men√ºs entfernen
        document.querySelectorAll(".dropdown-menu").forEach(menu => menu.remove());

        if (!event?.currentTarget) {
            console.error("‚ùå Fehler: Event-Target nicht gefunden.");
            return;
        }

        // Men√º erstellen
        let menu = document.createElement("div");
        menu.classList.add("dropdown-menu");
        menu.style.position = "absolute";
        menu.style.background = "#fff";
        menu.style.boxShadow = "0px 2px 5px rgba(0, 0, 0, 0.2)";
        menu.style.borderRadius = "5px";
        menu.style.padding = "10px";
        menu.style.zIndex = "1000";
        menu.style.display = "block";
        menu.style.minWidth = "120px";

        // üìå Bearbeiten
        const editOption = document.createElement("div");
        editOption.classList.add("menu-item");
        editOption.textContent = "Bearbeiten ‚úèÔ∏è";
        editOption.style.padding = "5px";
        editOption.style.cursor = "pointer";
        editOption.onclick = () => {
            console.log(`‚úèÔ∏è Bearbeiten angeklickt: listId=${listId}`);
            this.editList(listId);
            menu.remove();
        };

        // üìå L√∂schen
        const deleteOption = document.createElement("div");
        deleteOption.classList.add("menu-item");
        deleteOption.textContent = "L√∂schen üóëÔ∏è";
        deleteOption.style.padding = "5px";
        deleteOption.style.cursor = "pointer";
        deleteOption.onclick = () => {
            console.log(`üóëÔ∏è L√∂schen angeklickt: listId=${listId}`);
            this.deleteList(listId);
            menu.remove();
        };

        // üìå Teilen
        const shareOption = document.createElement("div");
        shareOption.classList.add("menu-item");
        shareOption.textContent = "Teilen üì§";
        shareOption.style.padding = "5px";
        shareOption.style.cursor = "pointer";
        shareOption.onclick = () => {
            console.log(`üì§ Teilen angeklickt: listId=${listId}`);
            this.shareList(listId);
            menu.remove();
        };

        // Optionen ins Men√º einf√ºgen
        menu.appendChild(editOption);
        menu.appendChild(deleteOption);
        menu.appendChild(shareOption);

        // Position des Men√ºs berechnen und verhindern, dass es aus dem Bildschirm rutscht
        const rect = event.currentTarget.getBoundingClientRect();
        const menuWidth = 150;
        menu.style.left = `${rect.left + window.scrollX}px`;
        menu.style.top = `${rect.bottom + window.scrollY}px`;

        if (rect.left + menuWidth > window.innerWidth) {
            menu.style.left = `${window.innerWidth - menuWidth - 10}px`; // Falls zu weit rechts, nach links verschieben
        }

        document.body.appendChild(menu);
        console.log("‚úÖ Dropdown-Men√º f√ºr Listen wurde hinzugef√ºgt:", menu);

        // Men√º schlie√üen, wenn au√üerhalb geklickt wird
        const closeMenu = (e) => {
            if (!menu.contains(e.target)) {
                console.log("‚ùå Men√º wird geschlossen");
                menu.remove();
                document.removeEventListener("click", closeMenu);
            }
        };

        setTimeout(() => {
            document.addEventListener("click", closeMenu);
        }, 100);
    }

// ‚úèÔ∏è Bearbeiten-Funktion f√ºr Listen
    editList(listId) {
        const list = this.model.getListById(listId);
        if (!list) {
            console.error(`‚ùå Fehler: Liste mit ID ${listId} nicht gefunden.`);
            return;
        }

        const newName = prompt("Neuer Name f√ºr die Liste:", list.name);
        if (newName && newName.trim() !== "") {
            list.name = newName;
            this.model.saveLists(); // Speichert die √Ñnderungen
            this.updateOverview(); // Aktualisiert die Listen√ºbersicht
            console.log(`‚úÖ Liste umbenannt in: ${newName}`);
        }
    }

// üóëÔ∏è L√∂schen-Funktion f√ºr Listen
    deleteList(listId) {
        if (!confirm("M√∂chtest du diese Liste wirklich l√∂schen?")) return;
        this.model.deleteList(listId);
        this.updateOverview(); // Aktualisiert die √úbersicht nach dem L√∂schen
        console.log(`üóëÔ∏è Liste mit ID ${listId} wurde gel√∂scht.`);
    }

// üì§ Teilen-Funktion f√ºr Listen
    shareList(listId) {
        const list = this.model.getListById(listId);
        if (!list) {
            console.error(`‚ùå Fehler: Liste mit ID ${listId} nicht gefunden.`);
            return;
        }

        const userEmail = prompt("Gib die E-Mail-Adresse ein, mit der du die Liste teilen m√∂chtest:");
        if (userEmail && userEmail.includes("@")) {
            console.log(`üì§ Liste "${list.name}" wurde mit ${userEmail} geteilt.`);
            alert(`üìß Liste "${list.name}" wurde erfolgreich mit ${userEmail} geteilt!`);
        } else {
            alert("‚ö†Ô∏è Bitte gib eine g√ºltige E-Mail-Adresse ein.");
        }
    }

    populateTagFilter() {
        const tagFilter = document.getElementById("tag-filter");
        if (!tagFilter) {
            console.error("‚ùå Fehler: `tag-filter` nicht gefunden!");
            return;
        }

        // Entferne alte Eintr√§ge
        tagFilter.innerHTML = "<option value=''>Alle</option>";

        // Erstelle eine Liste aller Tags
        const allTags = new Set();
        this.model.articles.forEach(article => {
            console.log("üîç Artikel geladen:", article.name, "Tags:", article.tags);
            if (article.tags && Array.isArray(article.tags)) {
                article.tags.forEach(tag => allTags.add(tag));
            }
        });

        console.log("üìå Alle gefundenen Tags:", [...allTags]);

        // Falls keine Tags existieren
        if (allTags.size === 0) {
            console.warn("‚ö†Ô∏è Keine Tags gefunden! Stelle sicher, dass `shoppinglist.json` Tags enth√§lt.");
            return;
        }

        // F√ºge Tags ins Dropdown ein
        allTags.forEach(tag => {
            const option = document.createElement("option");
            option.value = tag;
            option.textContent = tag;
            tagFilter.appendChild(option);
        });

        console.log("‚úÖ Tag-Filter aktualisiert:", [...allTags]);
    }
    addTag(tagName) {
        if (!tagName || tagName.trim() === "") return; // Leere Eingaben ignorieren

        tagName = tagName.trim();

        // Stelle sicher, dass der Tag nicht doppelt hinzugef√ºgt wird
        if (this.model.tags.includes(tagName)) {
            alert("‚ö†Ô∏è Tag existiert bereits!");
            return;
        }

        this.model.tags.push(tagName); // F√ºge den neuen Tag hinzu
        this.model.saveTags(); // Speichere die aktualisierte Tag-Liste

        this.populateTagFilter(); // Aktualisiere das Dropdown
        console.log(`‚úÖ Neuer Tag hinzugef√ºgt: ${tagName}`);
    }
    updateTagDropdown() {
        const tagFilter = document.getElementById("tag-filter");
        if (!tagFilter) {
            console.error("‚ùå Fehler: Tag-Filter Dropdown nicht gefunden!");
            return;
        }

        // üóëÔ∏è Bestehende Optionen entfernen (bis auf "Alle")
        tagFilter.innerHTML = '<option value="">Alle</option>';

        // üéØ Alle Tags aus dem Model holen und ins Dropdown einf√ºgen
        this.model.tags.forEach(tag => {
            const option = document.createElement("option");
            option.value = tag;
            option.textContent = tag;
            tagFilter.appendChild(option);
        });

        console.log("üîÑ Tag-Dropdown aktualisiert:", this.model.tags);
    }


}
